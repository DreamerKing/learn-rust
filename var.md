# 数据类型

变量声明
变量默认是不可变的，声明可变变量需要使用关键字`mut`。

常量
使用`const`声明，不能改变。不能使用`mut`关键字。
常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。

隐藏
可以定义一个与之前变量同名的新变量，后声明的变量会隐藏前面声明的同名变量。
可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏。

隐藏与将变量标记为 mut 的区别

- 当不小心尝试对变量重新赋值时，如果没有使用 let 关键字，就会导致编译时错误。通过使用 let，可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。
- 当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。

数据类型

- 标量
- 复合

- 自动推导
- 类型标注

标量类型 单值

- 整数 i8/u8, i16/u16, i32/u32, i64/u64, i128/u128, isize/usize
- 浮点数 f32, f64
- 布尔值 bool 1 个字节
- 字符 char 4 个字节

多种数字类型的数字字面值允许使用类型后缀，也允许使用 \_ 做为分隔符以方便读数。

复合类型 多值多类型

- 元组 可以不同类型，固定长度
- 数组 同一类型，固定长度 栈存储

标识符 snake case 蛇型命名法
函数

```rust
fn function_name(){}
```

Rust 不关心在那里定义函数，只要函数对于使用区域可见。
参数变量 parameter
传参 argument

表达式 执行计算并产生一个值作为结果的指令
语句 执行一些操作但不返回值的指令

函数返回值
需要声明返回类型
可以使用 return 提前返回
若不指定，则隐式返回最后一个表达式的值

注释

- 行注释 //
- 块注释 /\* \*/
- 文档注释

控制流

宏和函数
宏是根据一系列预定规则替换一定文本模式。实现将小命令自动转化为一系列指令。

toml 文件
[] 片段
[package]
[dependencies]

基本概念

- 变量
- 基本类型
- 函数
- 注释
- 控制流

## 结构体

结构体更新语法`..`, 表示未被显示设置的字段都与给定实例拥有相同的值,并且只能位于最后。

元组结构体
不需要为字段命名，仅保留字段类型
应用场景: 需要为元组命名以区别于拥有同样定义的元组类型

空结构体
没有任何字段
应用场景：需要在某一类型上实现一个trait,却不需要在这种类型上存储任何数据

derive注解可以派生trait,为自定义类型增加许多实用的功能。

方法和函数的异同

- 都使用`fn`及一个名称来进行声明
- 都可以拥有参数和返回值
- 都包含了一段调用时执行的代码
- 方法为实例指定行为

- 方法总定义在某个结构体、枚举类型或trait对象的上下文中
- 方法的第一个参数永远是self,用来指代调用该方法的实例
- self的类型无需显示标注，能够自动推导

关联函数 不接收self作为参数的函数，不会作用于某个实例。

## 枚举

枚举取值只能是枚举成员的其中之一。
每个枚举成员可以拥有不同类型和数量的关联数据
可以将任意类型的数据嵌入枚举成员中

Option<T>类型包含在预导入模块，无需显式引入作用域。

## 模式匹配

模式是Rust中一种用来匹配类型结构的特殊语法。

模式通常由以下组件组合而成:

- 字面量
- 解构的数组、枚举、结构体或元组
- 变量
- 通配符
- 占位符

模式用来描述数据结构(形状)，而数据结构可以用来匹配值，因而模式用来与某个特定值进行匹配。

可失败模式与不可失败模式的区别

### match

绑定值的模式
rust的匹配是穷尽的
通配符`_`  忽略不需处理的所有值，一般放在最后

## if let

match 和 if let 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。

- 相较于不可变变量而言，可变变量会让代码变得更加易于编写。
- 对于某些重型数据结构，适当地使用可变性去修改实例，可能比赋值和重新返回一个新分配的实例更有效率。
对于轻量的数据结构，采用更偏向函数式的风格，通过创建新的变量来进行赋值，可能会使代码更容易理解。

变量和常量的区别

- 常量不能使用mut关键字修饰，不仅默认不可变，并且总是不可变；
- 常量使用const关键字声明，必须显示标注类型；
- 常量可以声明在任何作用域中，甚至包括全局作用域；
- 只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值或需要在运行时计算的值绑定到常量上。

变量隐藏

可以重复使用let关键字并分配相同名称来不断隐藏变量,并且每次绑定的类型也可不同。
通过使用let,可以对值执行一系列变换操作，并允许这个变量在操作完成后保持自己的不可变性。

变量隐藏与可变变量的区别：重复使用let关键字会创建新的变量，可以在复用名称的同时改变变量的类型。

## 数据类型 标量类型和复合类型

Rust是静态类型语言，在编译程序的过程中需要知道变量的类型。大部分情况下，编译器通过变量的绑定、使用变量的值来自动推导出变量的类型,无法推导时需要手动标注。

Rust内置4种基础的标量类型：整数、浮点数、布尔值和字符。

- 整数类型 i8/i16/i32/i64/isize | u8/u16/u32/u64/usize
有符号和无符号的区别是否拥有描述负数的能力。类型`isize`和`usize`的长度由目标平台决定。
整数标量可以使用`_`分隔以方便读数，也可使用类型后缀。

整数溢出 值超出表示范围

Debug模式下编译出Rust程序中包含整数溢出的运行时检测代码，并在整数溢出时触发panic。而release模式下发生整数溢出时会执行二进制补码环绕。

- 浮点数 f32/f64 默认f64 采用IEEE-754进行表示

- 布尔类型 bool 占1个字节的空间 常用在if表达式内作为条件
- 字符类型 char 单个字符 使用单引号指定， 占4个字节空间，是一个Unicode标量值， Unicode标量可以描述从U+0000到U+D7FF和U+E000到U+10FFFF范围内所有值。

元组 tup `()`
不同类型的值组合 具有固定长度

数组 `[]`相同类型的值的集合 固定长度 存储在栈空间

动态数组 vec 相同类型，长度不固定 存储在堆空间

## 通用集合类型

数据存储在堆上,不需要在编译时确定数据大小,在运行时可以动态调整数据空间大小。不同的集合类型有着不同的性能特性和开销。

- 动态数组 vector
- 字符串
- 哈希映射

## 函数

Rust不关心函数定义的位置，只要定义在使用区域可见即可。

语句与表达式
表达式会执行计算并`产生一个值`作为结果返回
语句执行操作但`不返回值`

## 控制流语句

条件语句的条件表达式必须产生一个bool类型的值
条件语句无需使用中括号包括
条件语句会且仅会执行第一个条件为真的语句，一旦发现满足条件，便不会再继续检查后续的剩余的条件。
